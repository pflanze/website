// GENERATED by resources/generate-ahtml_elements-rs, DO NOT EDIT

lazy_static!{
    pub static ref A_META: &'static ElementMeta = METADB.elementmeta.get("a").unwrap();
}
lazy_static!{
    pub static ref ABBR_META: &'static ElementMeta = METADB.elementmeta.get("abbr").unwrap();
}
lazy_static!{
    pub static ref ADDRESS_META: &'static ElementMeta = METADB.elementmeta.get("address").unwrap();
}
lazy_static!{
    pub static ref AREA_META: &'static ElementMeta = METADB.elementmeta.get("area").unwrap();
}
lazy_static!{
    pub static ref ARTICLE_META: &'static ElementMeta = METADB.elementmeta.get("article").unwrap();
}
lazy_static!{
    pub static ref ASIDE_META: &'static ElementMeta = METADB.elementmeta.get("aside").unwrap();
}
lazy_static!{
    pub static ref AUDIO_META: &'static ElementMeta = METADB.elementmeta.get("audio").unwrap();
}
lazy_static!{
    pub static ref B_META: &'static ElementMeta = METADB.elementmeta.get("b").unwrap();
}
lazy_static!{
    pub static ref BASE_META: &'static ElementMeta = METADB.elementmeta.get("base").unwrap();
}
lazy_static!{
    pub static ref BDI_META: &'static ElementMeta = METADB.elementmeta.get("bdi").unwrap();
}
lazy_static!{
    pub static ref BDO_META: &'static ElementMeta = METADB.elementmeta.get("bdo").unwrap();
}
lazy_static!{
    pub static ref BLOCKQUOTE_META: &'static ElementMeta = METADB.elementmeta.get("blockquote").unwrap();
}
lazy_static!{
    pub static ref BODY_META: &'static ElementMeta = METADB.elementmeta.get("body").unwrap();
}
lazy_static!{
    pub static ref BR_META: &'static ElementMeta = METADB.elementmeta.get("br").unwrap();
}
lazy_static!{
    pub static ref BUTTON_META: &'static ElementMeta = METADB.elementmeta.get("button").unwrap();
}
lazy_static!{
    pub static ref CANVAS_META: &'static ElementMeta = METADB.elementmeta.get("canvas").unwrap();
}
lazy_static!{
    pub static ref CAPTION_META: &'static ElementMeta = METADB.elementmeta.get("caption").unwrap();
}
lazy_static!{
    pub static ref CITE_META: &'static ElementMeta = METADB.elementmeta.get("cite").unwrap();
}
lazy_static!{
    pub static ref CODE_META: &'static ElementMeta = METADB.elementmeta.get("code").unwrap();
}
lazy_static!{
    pub static ref COL_META: &'static ElementMeta = METADB.elementmeta.get("col").unwrap();
}
lazy_static!{
    pub static ref COLGROUP_META: &'static ElementMeta = METADB.elementmeta.get("colgroup").unwrap();
}
lazy_static!{
    pub static ref DATA_META: &'static ElementMeta = METADB.elementmeta.get("data").unwrap();
}
lazy_static!{
    pub static ref DATALIST_META: &'static ElementMeta = METADB.elementmeta.get("datalist").unwrap();
}
lazy_static!{
    pub static ref DD_META: &'static ElementMeta = METADB.elementmeta.get("dd").unwrap();
}
lazy_static!{
    pub static ref DEL_META: &'static ElementMeta = METADB.elementmeta.get("del").unwrap();
}
lazy_static!{
    pub static ref DETAILS_META: &'static ElementMeta = METADB.elementmeta.get("details").unwrap();
}
lazy_static!{
    pub static ref DFN_META: &'static ElementMeta = METADB.elementmeta.get("dfn").unwrap();
}
lazy_static!{
    pub static ref DIALOG_META: &'static ElementMeta = METADB.elementmeta.get("dialog").unwrap();
}
lazy_static!{
    pub static ref DIV_META: &'static ElementMeta = METADB.elementmeta.get("div").unwrap();
}
lazy_static!{
    pub static ref DL_META: &'static ElementMeta = METADB.elementmeta.get("dl").unwrap();
}
lazy_static!{
    pub static ref DT_META: &'static ElementMeta = METADB.elementmeta.get("dt").unwrap();
}
lazy_static!{
    pub static ref EM_META: &'static ElementMeta = METADB.elementmeta.get("em").unwrap();
}
lazy_static!{
    pub static ref EMBED_META: &'static ElementMeta = METADB.elementmeta.get("embed").unwrap();
}
lazy_static!{
    pub static ref FIELDSET_META: &'static ElementMeta = METADB.elementmeta.get("fieldset").unwrap();
}
lazy_static!{
    pub static ref FIGCAPTION_META: &'static ElementMeta = METADB.elementmeta.get("figcaption").unwrap();
}
lazy_static!{
    pub static ref FIGURE_META: &'static ElementMeta = METADB.elementmeta.get("figure").unwrap();
}
lazy_static!{
    pub static ref FOOTER_META: &'static ElementMeta = METADB.elementmeta.get("footer").unwrap();
}
lazy_static!{
    pub static ref FORM_META: &'static ElementMeta = METADB.elementmeta.get("form").unwrap();
}
lazy_static!{
    pub static ref H1_META: &'static ElementMeta = METADB.elementmeta.get("h1").unwrap();
}
lazy_static!{
    pub static ref H2_META: &'static ElementMeta = METADB.elementmeta.get("h2").unwrap();
}
lazy_static!{
    pub static ref H3_META: &'static ElementMeta = METADB.elementmeta.get("h3").unwrap();
}
lazy_static!{
    pub static ref H4_META: &'static ElementMeta = METADB.elementmeta.get("h4").unwrap();
}
lazy_static!{
    pub static ref H5_META: &'static ElementMeta = METADB.elementmeta.get("h5").unwrap();
}
lazy_static!{
    pub static ref H6_META: &'static ElementMeta = METADB.elementmeta.get("h6").unwrap();
}
lazy_static!{
    pub static ref HEAD_META: &'static ElementMeta = METADB.elementmeta.get("head").unwrap();
}
lazy_static!{
    pub static ref HEADER_META: &'static ElementMeta = METADB.elementmeta.get("header").unwrap();
}
lazy_static!{
    pub static ref HGROUP_META: &'static ElementMeta = METADB.elementmeta.get("hgroup").unwrap();
}
lazy_static!{
    pub static ref HR_META: &'static ElementMeta = METADB.elementmeta.get("hr").unwrap();
}
lazy_static!{
    pub static ref HTML_META: &'static ElementMeta = METADB.elementmeta.get("html").unwrap();
}
lazy_static!{
    pub static ref I_META: &'static ElementMeta = METADB.elementmeta.get("i").unwrap();
}
lazy_static!{
    pub static ref IFRAME_META: &'static ElementMeta = METADB.elementmeta.get("iframe").unwrap();
}
lazy_static!{
    pub static ref IMG_META: &'static ElementMeta = METADB.elementmeta.get("img").unwrap();
}
lazy_static!{
    pub static ref INPUT_META: &'static ElementMeta = METADB.elementmeta.get("input").unwrap();
}
lazy_static!{
    pub static ref INS_META: &'static ElementMeta = METADB.elementmeta.get("ins").unwrap();
}
lazy_static!{
    pub static ref KBD_META: &'static ElementMeta = METADB.elementmeta.get("kbd").unwrap();
}
lazy_static!{
    pub static ref LABEL_META: &'static ElementMeta = METADB.elementmeta.get("label").unwrap();
}
lazy_static!{
    pub static ref LEGEND_META: &'static ElementMeta = METADB.elementmeta.get("legend").unwrap();
}
lazy_static!{
    pub static ref LI_META: &'static ElementMeta = METADB.elementmeta.get("li").unwrap();
}
lazy_static!{
    pub static ref LINK_META: &'static ElementMeta = METADB.elementmeta.get("link").unwrap();
}
lazy_static!{
    pub static ref MAIN_META: &'static ElementMeta = METADB.elementmeta.get("main").unwrap();
}
lazy_static!{
    pub static ref MAP_META: &'static ElementMeta = METADB.elementmeta.get("map").unwrap();
}
lazy_static!{
    pub static ref MARK_META: &'static ElementMeta = METADB.elementmeta.get("mark").unwrap();
}
lazy_static!{
    pub static ref MENU_META: &'static ElementMeta = METADB.elementmeta.get("menu").unwrap();
}
lazy_static!{
    pub static ref META_META: &'static ElementMeta = METADB.elementmeta.get("meta").unwrap();
}
lazy_static!{
    pub static ref METER_META: &'static ElementMeta = METADB.elementmeta.get("meter").unwrap();
}
lazy_static!{
    pub static ref NAV_META: &'static ElementMeta = METADB.elementmeta.get("nav").unwrap();
}
lazy_static!{
    pub static ref NOSCRIPT_META: &'static ElementMeta = METADB.elementmeta.get("noscript").unwrap();
}
lazy_static!{
    pub static ref OBJECT_META: &'static ElementMeta = METADB.elementmeta.get("object").unwrap();
}
lazy_static!{
    pub static ref OL_META: &'static ElementMeta = METADB.elementmeta.get("ol").unwrap();
}
lazy_static!{
    pub static ref OPTGROUP_META: &'static ElementMeta = METADB.elementmeta.get("optgroup").unwrap();
}
lazy_static!{
    pub static ref OPTION_META: &'static ElementMeta = METADB.elementmeta.get("option").unwrap();
}
lazy_static!{
    pub static ref OUTPUT_META: &'static ElementMeta = METADB.elementmeta.get("output").unwrap();
}
lazy_static!{
    pub static ref P_META: &'static ElementMeta = METADB.elementmeta.get("p").unwrap();
}
lazy_static!{
    pub static ref PICTURE_META: &'static ElementMeta = METADB.elementmeta.get("picture").unwrap();
}
lazy_static!{
    pub static ref PRE_META: &'static ElementMeta = METADB.elementmeta.get("pre").unwrap();
}
lazy_static!{
    pub static ref PROGRESS_META: &'static ElementMeta = METADB.elementmeta.get("progress").unwrap();
}
lazy_static!{
    pub static ref Q_META: &'static ElementMeta = METADB.elementmeta.get("q").unwrap();
}
lazy_static!{
    pub static ref RP_META: &'static ElementMeta = METADB.elementmeta.get("rp").unwrap();
}
lazy_static!{
    pub static ref RT_META: &'static ElementMeta = METADB.elementmeta.get("rt").unwrap();
}
lazy_static!{
    pub static ref RUBY_META: &'static ElementMeta = METADB.elementmeta.get("ruby").unwrap();
}
lazy_static!{
    pub static ref S_META: &'static ElementMeta = METADB.elementmeta.get("s").unwrap();
}
lazy_static!{
    pub static ref SAMP_META: &'static ElementMeta = METADB.elementmeta.get("samp").unwrap();
}
lazy_static!{
    pub static ref SCRIPT_META: &'static ElementMeta = METADB.elementmeta.get("script").unwrap();
}
lazy_static!{
    pub static ref SEARCH_META: &'static ElementMeta = METADB.elementmeta.get("search").unwrap();
}
lazy_static!{
    pub static ref SECTION_META: &'static ElementMeta = METADB.elementmeta.get("section").unwrap();
}
lazy_static!{
    pub static ref SELECT_META: &'static ElementMeta = METADB.elementmeta.get("select").unwrap();
}
lazy_static!{
    pub static ref SLOT_META: &'static ElementMeta = METADB.elementmeta.get("slot").unwrap();
}
lazy_static!{
    pub static ref SMALL_META: &'static ElementMeta = METADB.elementmeta.get("small").unwrap();
}
lazy_static!{
    pub static ref SOURCE_META: &'static ElementMeta = METADB.elementmeta.get("source").unwrap();
}
lazy_static!{
    pub static ref SPAN_META: &'static ElementMeta = METADB.elementmeta.get("span").unwrap();
}
lazy_static!{
    pub static ref STRONG_META: &'static ElementMeta = METADB.elementmeta.get("strong").unwrap();
}
lazy_static!{
    pub static ref STYLE_META: &'static ElementMeta = METADB.elementmeta.get("style").unwrap();
}
lazy_static!{
    pub static ref SUB_META: &'static ElementMeta = METADB.elementmeta.get("sub").unwrap();
}
lazy_static!{
    pub static ref SUMMARY_META: &'static ElementMeta = METADB.elementmeta.get("summary").unwrap();
}
lazy_static!{
    pub static ref SUP_META: &'static ElementMeta = METADB.elementmeta.get("sup").unwrap();
}
lazy_static!{
    pub static ref TABLE_META: &'static ElementMeta = METADB.elementmeta.get("table").unwrap();
}
lazy_static!{
    pub static ref TBODY_META: &'static ElementMeta = METADB.elementmeta.get("tbody").unwrap();
}
lazy_static!{
    pub static ref TD_META: &'static ElementMeta = METADB.elementmeta.get("td").unwrap();
}
lazy_static!{
    pub static ref TEMPLATE_META: &'static ElementMeta = METADB.elementmeta.get("template").unwrap();
}
lazy_static!{
    pub static ref TEXTAREA_META: &'static ElementMeta = METADB.elementmeta.get("textarea").unwrap();
}
lazy_static!{
    pub static ref TFOOT_META: &'static ElementMeta = METADB.elementmeta.get("tfoot").unwrap();
}
lazy_static!{
    pub static ref TH_META: &'static ElementMeta = METADB.elementmeta.get("th").unwrap();
}
lazy_static!{
    pub static ref THEAD_META: &'static ElementMeta = METADB.elementmeta.get("thead").unwrap();
}
lazy_static!{
    pub static ref TIME_META: &'static ElementMeta = METADB.elementmeta.get("time").unwrap();
}
lazy_static!{
    pub static ref TITLE_META: &'static ElementMeta = METADB.elementmeta.get("title").unwrap();
}
lazy_static!{
    pub static ref TR_META: &'static ElementMeta = METADB.elementmeta.get("tr").unwrap();
}
lazy_static!{
    pub static ref TRACK_META: &'static ElementMeta = METADB.elementmeta.get("track").unwrap();
}
lazy_static!{
    pub static ref U_META: &'static ElementMeta = METADB.elementmeta.get("u").unwrap();
}
lazy_static!{
    pub static ref UL_META: &'static ElementMeta = METADB.elementmeta.get("ul").unwrap();
}
lazy_static!{
    pub static ref VAR_META: &'static ElementMeta = METADB.elementmeta.get("var").unwrap();
}
lazy_static!{
    pub static ref VIDEO_META: &'static ElementMeta = METADB.elementmeta.get("video").unwrap();
}
lazy_static!{
    pub static ref WBR_META: &'static ElementMeta = METADB.elementmeta.get("wbr").unwrap();
}

impl Allocator {
    #[allow(dead_code)]
    pub fn a(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&A_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn abbr(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&ABBR_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn address(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&ADDRESS_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn area(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&AREA_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn article(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&ARTICLE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn aside(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&ASIDE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn audio(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&AUDIO_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn b(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&B_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn base(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&BASE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn bdi(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&BDI_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn bdo(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&BDO_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn blockquote(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&BLOCKQUOTE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn body(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&BODY_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn br(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&BR_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn button(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&BUTTON_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn canvas(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&CANVAS_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn caption(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&CAPTION_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn cite(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&CITE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn code(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&CODE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn col(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&COL_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn colgroup(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&COLGROUP_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn data(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&DATA_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn datalist(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&DATALIST_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn dd(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&DD_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn del(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&DEL_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn details(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&DETAILS_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn dfn(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&DFN_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn dialog(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&DIALOG_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn div(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&DIV_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn dl(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&DL_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn dt(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&DT_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn em(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&EM_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn embed(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&EMBED_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn fieldset(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&FIELDSET_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn figcaption(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&FIGCAPTION_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn figure(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&FIGURE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn footer(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&FOOTER_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn form(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&FORM_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn h1(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&H1_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn h2(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&H2_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn h3(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&H3_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn h4(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&H4_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn h5(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&H5_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn h6(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&H6_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn head(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&HEAD_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn header(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&HEADER_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn hgroup(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&HGROUP_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn hr(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&HR_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn html(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&HTML_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn i(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&I_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn iframe(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&IFRAME_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn img(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&IMG_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn input(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&INPUT_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn ins(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&INS_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn kbd(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&KBD_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn label(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&LABEL_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn legend(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&LEGEND_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn li(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&LI_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn link(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&LINK_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn main(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&MAIN_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn map(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&MAP_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn mark(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&MARK_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn menu(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&MENU_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn meta(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&META_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn meter(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&METER_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn nav(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&NAV_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn noscript(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&NOSCRIPT_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn object(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&OBJECT_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn ol(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&OL_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn optgroup(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&OPTGROUP_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn option(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&OPTION_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn output(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&OUTPUT_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn p(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&P_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn picture(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&PICTURE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn pre(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&PRE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn progress(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&PROGRESS_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn q(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&Q_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn rp(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&RP_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn rt(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&RT_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn ruby(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&RUBY_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn s(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&S_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn samp(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SAMP_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn script(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SCRIPT_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn search(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SEARCH_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn section(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SECTION_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn select(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SELECT_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn slot(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SLOT_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn small(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SMALL_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn source(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SOURCE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn span(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SPAN_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn strong(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&STRONG_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn style(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&STYLE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn sub(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SUB_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn summary(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SUMMARY_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn sup(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&SUP_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn table(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TABLE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn tbody(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TBODY_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn td(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TD_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn template(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TEMPLATE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn textarea(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TEXTAREA_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn tfoot(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TFOOT_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn th(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TH_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn thead(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&THEAD_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn time(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TIME_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn title(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TITLE_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn tr(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TR_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn track(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&TRACK_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn u(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&U_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn ul(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&UL_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn var(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&VAR_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn video(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&VIDEO_META, attr, body)
    }
    #[allow(dead_code)]
    pub fn wbr(&self,
             attr: impl ToASlice<(KString, KString)>,
             body: impl ToASlice<Node>
    ) -> Result<AId<Node>>
    {
        self.element(&WBR_META, attr, body)
    }
}
