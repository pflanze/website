#!/usr/bin/env perl

my $copyright= <<'COPYRIGHT';
# Copyright 2023 by Christian Jaeger <ch@christianjaeger.ch>
# Published under the same terms as perl itself
COPYRIGHT

use strict;
use utf8;
use warnings;
use warnings FATAL => 'uninitialized';
use experimental 'signatures';

#use Chj::ruse;
#use Chj::Backtrace; 
#use FP::Show; use FP::Repl; use FP::Repl::Trap; #

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$0 resources/http-response-status-codes.txt src/http_response_status_codes.rs

  Convert the first to the second.
";
exit (@_ ? 1 : 0);
}

sub quote($str) {
    $str=~ s/"/\\"/sg;
    '"'.$str.'"'
}

package Header {
    use FP::Struct [
        "code",
        "name"
        ] => qw(FP::Struct::Show);
    sub rust($self) {
        "(" . $self->code . ", " . main::quote($self->name) . ")"
    }
    sub symbol($self) {
        my $str = $self->name;
        $str=~ s/\(.*//;
        $str=~ s/[ '-]//sg;
        ucfirst($str).$self->code
    }
    _END_ "main"
}

package Entry {
    use FP::Struct [
        "header",
        "lines"
        ] => qw(FP::Struct::Show);
    sub lines_cleaned($self) {
        map {
            my $line = $_;
            $line=~ s/\s+$//;
            if (length $line) {
                $line=~ s/^    // or warn "line missing indentation: '$line'";
                $line
            } else {
                ()
            }
        } @{$self->lines}
    }
    sub desc_string_code($self) {
        main::quote(join("\n\n", $self->lines_cleaned))
    }
    sub title_string_code($self) {
        main::quote($self->header->code . " " . $self->header->name)
    }
    sub rust($self) {
        "(" . $self->header->rust . ", " . $self->desc_string_code . ")"
    }
    sub symbol($self) {
        $self->header->symbol
    }
    _END_ "main"
}



usage unless @ARGV==2;
my ($inpath, $outpath) = @ARGV;

open my $in, "<", $inpath or die "$inpath: $!";

my $current_section;
my @entries;

my $current_header;
my $current_lines = [];

sub finish {
    push @entries, Entry($current_header, $current_lines);
    $current_lines = [];
}

while (<$in>) {
    chomp;
    next if /^##/;
    if (/^# (.*)/) {
        $current_section = $1;
        next;
    }
    if (/^(\d+) (.*)/) {
        if (defined $current_header) {
            finish;
        }
        $current_header = Header($1, $2);
    } else {
        if (defined $current_header) {
            push @$current_lines, $_;
        } else {
            next if /^\s*$/;
            die "bug: starts with non-empty line that's not a header nor section: '$_'"
        }
    }
}

finish;

open my $out, ">", $outpath or die "$outpath: $!";

print $out "
// AUTO-GENERATED by $0, DO NOT EDIT!

";

if (0) {
print $out "pub const HTTP_RESPONSE_STATUS_CODES: &[((u16, &'static str), &'static str)] = &[
".join("", map {
    $_->rust.",\n"
       } @entries)."];

";
}

print $out "
#[allow(dead_code)]
#[derive(Debug, Copy, Clone)]
pub enum HttpResponseStatusCode {
".join("", map {
    "    ".$_->symbol.",\n"
       } @entries)."}

impl HttpResponseStatusCode {
    #[allow(dead_code)]
    pub fn code(self) -> u16 {
        match self {
".join("", map {
    "            HttpResponseStatusCode::".$_->symbol." => ".$_->header->code.",\n"
       } @entries)."        }
    }

    #[allow(dead_code)]
    pub fn title(self) -> &'static str {
        match self {
".join("", map {
    "            HttpResponseStatusCode::".$_->symbol." => ".$_->title_string_code.",\n"
       } @entries)."        }
    }

    #[allow(dead_code)]
    pub fn desc(self) -> &'static str {
        match self {
".join("", map {
    "            HttpResponseStatusCode::".$_->symbol." => ".$_->desc_string_code.",\n"
       } @entries)."        }
    }
}
";


close $out or die $!;
